# Research: Отчет по мероприятиям (Stripe)

Дата: 2025-11-10  
Цель: закрыть вопросы Phase 0 из плана и подготовить основу для `data-model.md`, `contracts/` и реализации.

## R1. Доступ к `Checkout Line Item Summary`

- **Изученные эндпоинты**:
  - `stripe.checkout.sessions.list({ payment_status: 'paid', expand: ['data.line_items'] })` — возвращает сессии оплаты, можно фильтровать по периоду (`created` c Unix timestamp/диапазоном).
  - `stripe.checkout.sessions.listLineItems(sessionId, { expand: ['data.price.product'] })` — альтернативный запрос line items, если не использовать `expand` в списке.
  - Для полноты картины — `stripe.paymentIntents.list({ status: 'succeeded' })` и `stripe.refunds.list()` для контроля возвратов (не включаем в отчёт, но используем для валидации).
- **Получение названия мероприятия**: в Stripe Checkout Summary название лежит в `line_item.description`. При необходимости можно fallback на `line_item.price.product.name`. Для доступа к описанию нужно либо `expand: ['data.line_items']`, либо отдельный `listLineItems`.
- **Статус успешной оплаты**: для Checkout Sessions используем `payment_status === 'paid'` и `status === 'complete'`. Возвраты имеют отдельные объекты, поэтому их исключаем.
- **Решение**: основным источником будет `checkout.sessions.list` с `expand=line_items`. Для каждого line item проверяем `line_item.description` ⇒ агрегируем по нему. Период и пагинация (максимум 100 записей за запрос) покрываются параметрами `limit` + `starting_after`. Для отчёта по конкретному мероприятию фильтруем сессии и line items в коде.

## R2. Идентификация участников

- **Доступные поля**:
  - `session.customer_details.name` и `session.customer_details.email` доступны сразу, даже если нет зарегистрированного объекта Customer.
  - Если используется полноценный Customer, `session.customer` указывает на ID (`cus_...`), который можно дополнительно запросить через `stripe.customers.retrieve` для уточнения имени.
  - Поле `session.metadata` может содержать кастомные атрибуты (например, название мероприятия). Пока не используем, но оставляем как расширение.
- **Правила агрегирования**:
  - Основной ключ участника: `customer_details.email`. Если email отсутствует, используем `customer_details.name`. Для консистентности выводим оба столбца в отчёте (имя + email).
  - Если в рамках одной сессии несколько line items с одинаковым summary и разными количествами, агрегируем в одну запись участника.
- **Маскировка данных**:
  - В UI показываем полное имя и email (финансовой команде это необходимо), но в логах выводим только hash/email с маской (`a***@domain.com`).
  - В экспортируемом CSV оставляем полные значения по согласованию с бухгалтерией (необходимы для сверки платежей).

## R3. Валюты и округление

- Stripe хранит суммы в минимальных единицах (cents). SDK возвращает поля `amount_total`, `amount_subtotal` и т.д. в integer-формате.
- Аккаунт Stripe использует основную валюту PLN, поэтому для большинства мероприятий валюта совпадает. Возможны платежи в EUR/USD — встречаются в отдельных событиях.
- **Решение**:
  - В отчёт включаем поле `currency`. Если в мероприятии встречаются разные валюты, помечаем отчёт как требующий ручной проверки (не смешиваем значения).
  - При вычислениях маржи и VAT используем `amount_total / 100` (или `Stripe.utils.convertToDecimal`), потом применяем фиксированную ставку 23% и округляем до двух знаков методом bankers rounding (используем `Intl.NumberFormat` или собственную функцию).
  - На будущие итерации: возможна автоматическая конвертация по курсу НБП на дату платежа. Сейчас обходимся предупреждением.

## R4. Логирование и безопасность ключей

- **API ключ**:
  - Используем restricted key с правами `read_only` на Checkout Sessions, PaymentIntents, Customers.
  - Храним в `.env` переменной `STRIPE_API_KEY`. Для Render — добавляем в dashboard. Ключ не логируем, не выводим в ошибки.
- **Авторизация отчёта**:
  - Повторно используем существующий middleware (`src/middleware/auth.js`) для проверки сессии/Google OAuth.
  - Эндпоинты помещаем за /api/reports/stripe-events, доступна только авторизованным пользователям роли «finance».
- **Логирование**:
  - На уровне сервиса логируем только агрегированные данные: количество сессий, общее число line items, total amount, длительность запроса.
  - Ошибки Stripe: логируем код ошибки (`err.code`), HTTP статус и correlation-id, но не тело запроса/ответа.
  - Корреляция: на входе API генерируем `reportRequestId` и прокидываем его в каждый вызов Stripe (`stripe.headers['Idempotency-Key']` или `stripe.setAppInfo`+custom header через `requestOptions`).
  - Для отладки допускается debug-режим с выводом первых N символов email, но только при включённом флаге `ALLOW_PII_DEBUG` (по умолчанию `false`).

## R5. Контрольный набор данных

- Требуется сформировать или запросить у финансов:
  - Список 1–2 мероприятий с 5–10 платежами каждое (реальные данные в тестовом режиме или обезличенные).
  - Экспорт выписки Stripe (`Payments > Export`, формат CSV) и скриншот итогового отчёта для сверки.
  - Перечень расходов по мероприятию (общая сумма и декомпозиция), чтобы проверить распределение.
- Для разработки можно использовать Stripe test mode:
  - Создать Checkout продукт «Event XYZ», провести 3–4 тестовых платежа картой с разными именами.
  - Проверить, что `line_item.description` = заданное название.
  - Зафиксировать контрольные суммы и использовать их в unit/integration тестах.
- Финальный контроль: сверить результаты отчёта с предоставленной таблицей (как в примере на скриншоте) — это станет основой acceptance теста.

## Выводы Phase 0

1. Источник данных — `checkout.sessions.list` с `expand=line_items`; агрегирование по `line_item.description`.
2. Участников идентифицируем по email, имя используем для отображения; PII маскируем в логах.
3. Основная валюта — PLN; при обнаружении другой валюты выводим предупреждение и не смешиваем суммы.
4. Безопасность: используем restricted API key в `.env`, авторизацию существующим middleware, логируем только агрегаты и ошибки без PII.
5. Контрольный набор данных собираем через Stripe test mode и/или реальные обезличенные данные, фиксируем для тестов.

**Готовность**: вопросы Gate из плана закрыты (логирование, ключи, PII). Можно переходить к Phase 1 (data-model.md, contracts, quickstart).

