# Research Notes — Stripe Payment Processor

## Topic 1 — Testing strategy for new processor

- **Decision**: Использовать комбинированный подход: (a) локальные smoke-скрипты `npm run dev` + тестовые Stripe ключи для проверки обработки 1–2 сессий; (b) интеграционный сценарий «две сделки → два платежа» как ручной чек-лист перед релизом; (c) пост-деплой мониторинг логов по runId.
- **Rationale**: В репозитории отсутствуют автоматические юнит-тесты; добавление полной тестовой матрицы займет слишком много времени. Smoke-сценарии дают уверенность в основных путях (import, stage update, refunds) и вписываются в существующий процесс.
- **Alternatives considered**:
  1. **Unit tests Jest** — потребуют значительной рефакторизации legacy-кода (`invoiceProcessing`). Отложено.
  2. **Stripe CLI replays** — удобны, но не покрывают CRM-часть. Можно использовать доп. инструментом, но не как основной план.

## Topic 2 — Stripe Checkout Sessions best practices

- **Decision**: Для каждой оплаты создаём отдельную Checkout Session с `price_data` (динамическая цена), общим `product_id` кемпа, `customer_email`, metadata (`deal_id`, `participant_id`, `payment_type`, `invoice_number`). Используем `expand[]=line_items` при выгрузке и `pagination` с `starting_after`.
- **Rationale**: Такой паттерн совпадает с текущим UX (индивидуальные суммы) и упрощает агрегацию по продукту. Metadata обеспечивает идемпотентность и связь с CRM.
- **Alternatives**:
  1. **Fixed Price objects** — не решают индивидуальные суммы, привели бы к взрывному росту price-ов.
  2. **Stripe Invoices** — хуже поддерживают частичные оплаты и гибкие скидки, уже отклонено бизнесом.

## Topic 3 — Pipedrive stage automation

- **Decision**: Использовать Pipedrive REST `PUT /deals/{id}` для смены стадии сразу после записи платежа. Стадии определяются правилом: `close_date - today >= 30` → ожидаем 2 платежа. Последовательность: `First Payment` (stage_id=18) → `Second Payment` (stage_id=32) → `Camp waiter` (stage_id=27).
- **Rationale**: Соответствует текущему ProForm процессу и требованиям пользователя. Изменения стадий происходят в одном месте, что упрощает аудит.
- **Alternatives**:
  1. **Запуск отдельного webhook listener** — избыточно; у нас уже есть процессор, знающий, сколько платежей у сделки.
  2. **Ручное обновление менеджерами** — сильно увеличит ошибки и задержки.

## Topic 4 — Refund/delete alignment

- **Decision**: Все Stripe refunds/voids записываются в таблицу удалённых проформ (аналог Supabase log), выставляя отрицательные суммы и пометки `source=stripe`. Одновременно пересчитываем агрегаты отчётов по продукту и месяцу, чтобы суммы совпадали.
- **Rationale**: Пользователи привыкли искать удалённые документы в одном месте; повторяем процесс ProForm. Так же выполняем требование очищать отчёты.
- **Alternatives**:
  1. **Отдельная таблица refunds** — усложнит отчёты и экспорт, потребуется дублировать логику фильтров.
  2. **Игнорировать возвраты до ручной обработки** — нарушит «Invoice Data Fidelity».

## Topic 5 — Supabase concurrency & idempotency

- **Decision**: Использовать комбинацию `(deal_id, session_id)` как уникальный ключ Stripe платежа и `(deal_id, invoice_number)` для документов. Перед записью проверяем существование в Supabase (как в `findExistingProformaForDeal`). Повторные запуски используют этот ключ, чтобы не создавать дубликатов.
- **Rationale**: Следует существующей архитектуре ProForm и обеспечивает безопасное повторное выполнение процессора.
- **Alternatives**:
  1. **Глобальный hash payload-а** — сложнее отлаживать и не даёт быстрых ссылок на CRM.
  2. **Полагаться на Stripe idempotency keys** — они работают только в момент создания, а мы импортируем уже совершённые платежи.

## Topic 6 — B2B реквизиты и организация

- **Decision**: При обработке платежа проверяем `deal.org_id`. Если организация есть, запрашиваем `organization.name`, `organization.address`, `organization.country`, `organization.nip` (или эквивалент), сохраняем эти поля в `StripePayment` и добавляем их в Checkout Session (`customer_details`, `metadata`). Для B2C fallback используем данные person/metadata. В отчётах отображаем и B2B, и B2C платежи единым образом.
- **Rationale**: Бизнес кейсы кемпов включают корпоративные клиенты; без хранения NIP и юр. адреса документы и отчёты будут неполными. Интеграция с Pipedrive уже предоставляет эти данные.
- **Alternatives**:
  1. **Всегда требовать заполнение person** — ломает корпоративный flow и не решает НДС.
  2. **Создавать отдельную таблицу организаций** — избыточно, пока достаточно ссылаться на данные Pipedrive в момент записи.

## Topic 7 — VAT расчёты и режим Stripe Tax

- **Decision**: Использовать Stripe Tax в режиме «collect, but not remit»: процессор включает `automatic_tax.enabled=true` только для сделок с country = `PL`, чтобы Stripe рассчитывал VAT, но не удерживал средства. Суммы VAT (`amount_tax`, `amount_tax_pln`, `tax_behavior`, `tax_rate_id`) сохраняются в Supabase и попадают в отчёты. Если адрес/страна отсутствуют, Checkout не создаётся, и в CRM ставится задача «Заполнить адрес/страну и перевыставить invoice».
- **Rationale**: Компания работает по VAT Margin и хочет платить налог самостоятельно. Расчёт в Stripe облегчает контроль сумм и не требует отдельного калькулятора, но средства должны оставаться на счету.
- **Alternatives**:
  1. **Stripe полностью управляет VAT (remit)** — противоречит требованиям бизнеса; деньги списываются автоматически.
  2. **Полностью ручной расчёт VAT** — увеличивает риск ошибок и дублирования логики, особенно при мультивалютности.

