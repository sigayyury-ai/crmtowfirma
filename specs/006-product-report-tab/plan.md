# План внедрения: вкладка «Отчет по продуктам»

## Обзор

Цель — добавить во фронтенд VAT Margin Tracker новую вкладку с продуктовой аналитикой за весь период продаж и обеспечить backend-слой, который агрегирует данные по проформам без дополнительного экспорта. План описывает обновления по данным, API и интерфейсу, а также этапы тестирования и риски.

## Технический контекст

- **Текущая вкладка «Отчет по месяцам»** (`frontend/vat-margin-script.js`): использует табовую навигацию и запрос `GET /api/vat-margin/monthly-proformas`, который возвращает сгруппированные данные по продуктам в выбранном периоде.
- **Backend агрегация** (`src/routes/api.js`, `src/services/vatMargin/wfirmaLookup.js`):
  - Обращается к Supabase таблице `proforma_products` с привязкой к `proformas` и `products`.
  - При отсутствии данных в Supabase выполняет XML-запросы к wFirma и собирает группы на лету.
- **Формат фронтенд-рендера**: `renderVatMarginTable` группирует строки по `product_id/product_key` и выводит агрегаты в PLN/исходных валютах.
- **Статусы продукта**: отдельная таблица или поля в `products`, где нужно хранить `calculationStatus` («В процессе»/«Рассчитан») и `calculationDueMonth` (формат `YYYY-MM`).
- **Репликация прав доступа**: вкладки управляются на фронте без отдельной авторизации; права совпадают со стандартным UI.

## Стратегия реализации

### Этап 0. Подготовка данных и требований
- Уточнить структуру таблиц Supabase (`proforma_products`, `products`, `proformas`) и наличие исторических данных.
- Проверить, есть ли мягко удалённые/архивные продукты и как они помечаются.
- Согласовать финальный набор метрик с командой финансов (при необходимости).

### Этап 1. Backend: агрегированная сводка по продуктам
1. Добавить метод `getAllTimeProformasByProduct` в `WfirmaLookup`:
   - Переиспользовать текущий пайплайн Supabase → wFirma без фильтра по датам.
   - Ограничить выборку пагинацией/батчами, если объём слишком большой (проверить лимиты Supabase).
   - Рассчитать агрегаты: количество проформ, суммы в оригинальных валютах, конвертация в PLN, маржа, средний чек.
   - Сохранить структуру, удобную для фронта (`productId`, `productName`, `totals`, `currencyBreakdown`).
2. Обогащать результат полями `calculationStatus` и `calculationDueMonth`, считывая их из отдельной таблицы/колонок (при отсутствии — подставлять «В процессе» и `null`).
3. Добавить кеширующий слой (in-memory или Redis, если уже используется) либо параметр `forceRefresh`, чтобы не перегружать внешние API.
4. Обновить `computeSummary`, чтобы он работал и с новой сводкой (общая выручка/маржа, доли).

### Этап 2. Backend: детальный отчет по продукту
1. Реализовать метод `getProductDetail(productKey)` в `WfirmaLookup`:
   - Возвращать агрегаты верхнего уровня (totals).
   - Формировать `monthlyBreakdown` (группировка по `YYYY-MM`), `proformas[]` (дата, номер, суммы, статус оплаты, клиент).
   - Обеспечить сортировку по дате (новые сверху).
2. Добавить нормализацию ключей: поддержка `product_id` и текстовых ключей для совместимости со старыми данными.
3. Обработать случаи, когда продукт отсутствует (возвращать пустые массивы и информацию для UI).
4. Включить в ответ текущий `calculationStatus` и `calculationDueMonth` для отображения и редактирования.

### Этап 3. API-слой
1. Добавить новые endpoints в `src/routes/api.js`:
   - `GET /api/vat-margin/products/summary` — возвращает список продуктов с агрегатами (с пагинацией и сортировкой по умолчанию).
   - `GET /api/vat-margin/products/:productKey/detail` — возвращает детальный отчет.
   - `POST /api/vat-margin/products/:productKey/status` — сохраняет ручной статус и месяц расчёта.
2. Расширить схему ответа:
   - `summary`: массив продуктов + общие totals по всем продуктам.
   - `detail`: объект с `totals`, `monthlyBreakdown`, `proformas`, `meta` (название продукта, дата последней продажи).
3. Добавить валидацию входных параметров (ограничения на длину ключа, формат `YYYY-MM`, whitelist статусов, фильтры по статусу продукта).
4. Обработать конкурентные изменения (использовать optimistic lock или overwrite с отметкой автора/времени).
5. Логирование и обработка ошибок в том же стиле, что и текущие VAT Margin endpoints.

### Этап 4. Frontend: новая вкладка и UI
1. Обновить `vat-margin.html`/`index.html` и `vat-margin-script.js`:
   - Добавить кнопку таба `data-tab="products"`, контейнер `tab-products`, спиннер/заглушку.
   - Расширить `initTabs`/`switchTab`, чтобы при первом открытии загружались данные сводки по продуктам.
2. Реализовать функции:
   - `loadProductSummary()` — запрос сводки, рендер таблицы с сортировкой и поиском.
    - `renderProductSummaryTable(products)` — отображение названия, продаж, маржи, доли и др. метрик, а также колонок «Статус» и «Месяц расчёта» с индикаторами, сортировка по умолчанию: сначала «В процессе», затем «Рассчитан» (с возможностью дальнейшей ручной сортировки).
   - `openProductDetail(productKey)` — запрос детального отчета и отображение в модальном окне/панели.
   - `renderProductDetailView(detail)` — блок totals, раскладка по месяцам, таблица проформ, блок редактирования статуса и месяца.
   - `saveProductStatus(productKey, statusPayload)` — отправка изменений статуса и месяца на API, отображение результата/ошибок.
3. Продумать UX для продуктов без продаж (показывать «нет данных», disable кнопки) и для ручного статуса (цветовые метки, подтверждение изменений).
4. Адаптировать CSS (`frontend/style.css`) под новый таб и таблицы, не ломая существующий UI, добавить стили для статусов и инпута `YYYY-MM`.

### Этап 5. Обновление данных и ресинхронизация
- Проверить расписание обновлений VAT Margin (cron/скрипты). Убедиться, что новая выборка интегрируется в существующий цикл.
- При необходимости добавить job для предварительного кеширования сводки (чтобы UI не ждал минутный подсчёт).
- Синхронизировать обновление статусов: изменения по API не должны перезаписываться nightly-скриптами (добавить отдельный source-of-truth для статусов).

### Этап 6. Тестирование и стабилизация
1. **Unit**:
   - Тесты на агрегаторы и мапперы (синтетические данные) — убедиться в корректных суммах/долях.
2. **Integration**:
   - Проверка API `/summary` и `/detail` с демо-данными в Supabase.
   - Тесты fallback-сценариев wFirma (имитация пустых данных в Supabase).
3. **UI/UX**:
   - Проверка рендеринга в браузере (Chrome/Firefox), реакция на клики, отображение пустых состояний.
   - Нагрузочный тест: 1 000 продуктов, 500 проформ в детализации (замер скорости < 3–5 сек).
4. **Регресс**: убедиться, что месячный отчет не затронут (ручные проверки и автоматизированные smoke-тесты, если есть).

## Технические решения

1. **Формат ключа продукта**: использовать `product_id`, при отсутствии — нормализованное имя (логика уже есть в `WfirmaLookup`).
2. **Перфоманс**: внедрить базовый кеш (например, хранить результат сводки в памяти 15 минут) и предусмотреть invalidate при обновлении данных.
3. **Детализация**: отделить REST вызовы `summary` и `detail`, чтобы не возвращать тяжёлые данные сразу.
4. **Хранение статусов**: либо расширить таблицу `products` колонками `calculation_status`, `calculation_due_month`, либо создать отдельную таблицу `product_calculation_statuses` с полями (`product_id`, `status`, `due_month`, `updated_by`, `updated_at`).

## Требуемые исследования

- Подтвердить, что Supabase содержит полную историю проформ и продуктов (нет ли ограничений по давности/архиву).
- Уточнить, нужно ли отображать архивные продукты (если да — метки и фильтры).
- Проверить, доступны ли маржинальные показатели напрямую или требуется перерасчёт (в wFirma данные по себестоимости могут отсутствовать).
- Определить, нужно ли логировать историю изменений статуса (audit trail) и кто может редактировать значения.

## План тестирования

- **Smoke**: успешная загрузка вкладки, корректные значения totals, отсутствие ошибок в консоли.
- **E2E**: сценарий «открыть вкладку → выбрать продукт → сверить суммы с ежемесячным отчетом» минимум на трёх продуктах.
- **UI**: проверка ручного изменения статуса и месяца, подтверждение сохранения, обновление таблицы без перезагрузки.
- **Edge cases**: продукт без продаж, продукт только с историческими продажами, продукт с несколькими валютами.
- **Отказоустойчивость**: имитация недоступности Supabase (падение до wFirma) и проверка сообщений на фронте.

## Риски и смягчающие действия

- **Большой объём данных** → предусмотреть пагинацию в API и ленивую подгрузку на фронте.
- **Несогласованность данных между отчётами** → автоматические сравнения totals между существующим месячным и новым продуктовым API.
- **Падение производительности Supabase/zапросов wFirma** → кеширование, ограничение частоты запросов, резервный канал ручного обновления.
- **Человеческий фактор при смене статусов** → добавить подсказки и визуальные индикаторы, возможно — напоминания или отчёт об устаревших статусах.

## Метрики «готовности к релизу»

- Все acceptance-кейсы из спецификации покрыты тестами или чек-листами.
- API `/summary` и `/detail` отвечают <1 секунды при данных до 50 тыс. проформ (с учётом кеша).
- UX проверен на целевых ролях (финансовые менеджеры дают положительный фидбек).
- В логах отсутствуют повторяющиеся ошибки после 24 часов работы на стейдже.
- 100% продуктов имеют заполненный статус после миграции и ручной проверки.

