# Стратегия развертывания микросервисов

**Дата**: 2026-02-02  
**Цель**: Объяснить модель развертывания микросервисной архитектуры и влияние на стоимость

## Текущая модель развертывания

### Как это работает сейчас

```
Render Service (один сервис)
└── Node.js процесс
    ├── Express.js сервер
    ├── StripeProcessorService (монолит)
    ├── Все существующие сервисы
    └── Cron jobs
```

**Стоимость**: 1 сервис на Render (текущая стоимость)

---

## Модель развертывания после миграции

### Фазы 1-7: Микросервисы как классы (один процесс)

```
Render Service (один сервис) - СТОИМОСТЬ НЕ МЕНЯЕТСЯ
└── Node.js процесс
    ├── Express.js сервер
    ├── StripeProcessorService (уменьшенный монолит)
    │   └── Вызывает микросервисы синхронно
    │
    ├── src/services/microservices/
    │   ├── ValidationService (класс)
    │   ├── DuplicatePreventionService (класс)
    │   ├── NotificationService (класс)
    │   ├── CRMStatusService (класс)
    │   ├── PaymentProcessingService (класс)
    │   └── ... (все остальные микросервисы)
    │
    ├── Event Bus (in-memory EventEmitter)
    └── Cron jobs
```

**Ключевые моменты**:
- ✅ Все микросервисы - это **классы JavaScript** в одном процессе
- ✅ Вызываются **синхронно** из монолита (как обычные функции)
- ✅ **Один сервис на Render** - стоимость не меняется
- ✅ Нет необходимости в отдельных контейнерах или процессах
- ✅ Нет необходимости в отдельной инфраструктуре (RabbitMQ, Redis и т.д. на начальном этапе)

**Стоимость**: 1 сервис на Render (та же стоимость, что и сейчас)

---

## Будущая модель (опционально, только при необходимости)

### Когда может понадобиться разделение на отдельные сервисы

Разделение на отдельные сервисы на Render **НЕ требуется** для работы микросервисной архитектуры. Это нужно только если:

1. **Масштабирование**: Один сервис не справляется с нагрузкой
2. **Изоляция**: Критичный сервис нужно изолировать от остальных
3. **Независимое развертывание**: Нужно деплоить сервисы независимо друг от друга
4. **Разные технологии**: Какой-то сервис требует другой runtime (например, Python)

### Пример будущей архитектуры (если понадобится)

```
Render Services (несколько сервисов) - СТОИМОСТЬ УВЕЛИЧИТСЯ
├── Main API Service ($X/месяц)
│   └── Express.js + монолит
│
├── Payment Processing Service ($X/месяц)
│   └── PaymentProcessingService
│
├── Notification Service ($X/месяц)
│   └── NotificationService
│
└── Event Bus (RabbitMQ/Redis) ($X/месяц)
    └── Внешний брокер сообщений
```

**Когда это нужно**: Только при реальной необходимости масштабирования или изоляции.

---

## Преимущества текущего подхода (микросервисы как классы)

### 1. Экономия средств
- ✅ **Нет дополнительных расходов** на Render
- ✅ Один сервис = одна стоимость
- ✅ Нет необходимости в отдельной инфраструктуре (RabbitMQ, Redis)

### 2. Простота развертывания
- ✅ Один деплой вместо множества
- ✅ Нет проблем с версионированием между сервисами
- ✅ Нет необходимости настраивать сеть между сервисами

### 3. Производительность
- ✅ Нет сетевых задержек между сервисами (все в одном процессе)
- ✅ Нет накладных расходов на сериализацию/десериализацию
- ✅ Быстрая коммуникация через прямые вызовы методов

### 4. Отладка и мониторинг
- ✅ Все логи в одном месте
- ✅ Проще отслеживать flow между сервисами
- ✅ Нет проблем с distributed tracing

---

## Когда переходить на отдельные сервисы?

### Критерии для разделения:

1. **Нагрузка**: Один процесс не справляется (CPU > 80%, память > 80%)
2. **Масштабирование**: Нужно масштабировать только один сервис (например, Notification Service)
3. **Изоляция**: Критичный сервис падает и тянет за собой остальные
4. **Команда**: Разные команды работают над разными сервисами и нужна независимость

### Рекомендация

**НЕ разделять на отдельные сервисы на Render**, пока:
- ✅ Текущий сервис справляется с нагрузкой
- ✅ Нет проблем с производительностью
- ✅ Команда небольшая и работает над одним проектом
- ✅ Бюджет ограничен

**Разделять**, когда:
- ❌ Текущий сервис не справляется с нагрузкой
- ❌ Нужно масштабировать только один сервис
- ❌ Есть реальная необходимость в изоляции
- ❌ Бюджет позволяет и есть реальная бизнес-потребность

---

## Альтернативные подходы (если нужна изоляция без увеличения стоимости)

### 1. Worker процессы в том же сервисе

```
Render Service (один сервис)
├── Main Process (Express.js)
└── Worker Processes (микросервисы)
    ├── Validation Worker
    ├── Notification Worker
    └── Payment Processing Worker
```

**Преимущества**: Изоляция без дополнительных сервисов на Render

### 2. Использование Render Cron Jobs

Для периодических задач (напоминания, проверки) можно использовать Render Cron Jobs вместо основного сервиса.

**Преимущества**: Изоляция cron задач без дополнительного сервиса

---

## Итоговая рекомендация

### Для текущей миграции:

1. ✅ **Микросервисы как классы** в одном процессе
2. ✅ **Один сервис на Render** - стоимость не меняется
3. ✅ **Синхронные вызовы** между микросервисами
4. ✅ **In-memory EventEmitter** для начала (без внешних зависимостей)

### В будущем (если понадобится):

1. ⚠️ Разделение на отдельные сервисы только при реальной необходимости
2. ⚠️ Внешний Event Bus (RabbitMQ/Redis) только при необходимости асинхронности
3. ⚠️ Отдельные контейнеры только при необходимости масштабирования

**Главное**: Микросервисная архитектура - это **архитектурное разделение кода**, а не обязательно **инфраструктурное разделение**. Можно получить все преимущества микросервисов (модульность, тестируемость, изоляция логики) без увеличения стоимости инфраструктуры.
