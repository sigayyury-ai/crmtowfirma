# Сравнение текущей и предложенной архитектуры Stripe платежей

**Дата анализа**: 2026-02-02  
**Текущая система**: Монолитная архитектура  
**Предложенная система**: Микросервисная архитектура

## Краткий ответ

**НЕТ, новая архитектура НЕ реализована.** Текущая система использует **монолитную архитектуру** с одним большим классом `StripeProcessorService` (6420+ строк кода), который выполняет все функции. Предложенная микросервисная архитектура - это **план миграции**, а не текущее состояние.

## Текущая архитектура (Монолит)

### Структура

```
src/services/stripe/
├── processor.js                    (6420+ строк) ⚠️ МОНОЛИТ
│   ├── processPendingPayments()   - обработка всех платежей
│   ├── persistSession()           - сохранение платежа
│   ├── triggerCrmStatusAutomation() - обновление CRM
│   ├── sendPaymentNotificationForDeal() - отправка уведомлений
│   └── ... (множество других методов)
│
├── paymentSessionCreator.js        - создание сессий (используется внутри processor)
├── secondPaymentSchedulerService.js - планирование вторых платежей
├── repository.js                  - работа с БД
├── service.js                     - вспомогательные функции
└── ... (другие сервисы как зависимости)
```

### Как работает текущая система

**1. Создание сессии:**
```
CRM → API Gateway → routes/stripeWebhook.js или routes/api.js
  → PaymentSessionCreator.createSession()
  → Stripe API
  → Сохранение в БД через repository
  → Отправка уведомления через processor.sendPaymentNotificationForDeal()
```

**2. Обработка платежа (webhook):**
```
Stripe Webhook → routes/stripeWebhook.js
  → StripeProcessorService (монолитный класс)
    ├── Валидация подписи
    ├── Обработка события
    ├── Сохранение платежа (persistSession)
    ├── Обновление CRM статуса (triggerCrmStatusAutomation)
    ├── Отправка уведомления (sendPaymentNotificationForDeal)
    └── Все в одном процессе, синхронно
```

**3. Планирование напоминаний:**
```
Cron → scheduler.js
  → SecondPaymentSchedulerService
    → Использует StripeProcessorService внутри
    → Создание сессий, отправка уведомлений
```

### Характеристики текущей архитектуры

✅ **Что работает хорошо:**
- Все функции в одном месте - легко найти код
- Простое развертывание (один процесс)
- Нет проблем с распределенными транзакциями
- Простое логирование (один процесс)

❌ **Проблемы:**
- **Монолитный класс** (6420+ строк) - сложно поддерживать
- **Тесная связанность** - все функции зависят друг от друга
- **Нет изоляции ошибок** - ошибка в одной функции может сломать весь процесс
- **Невозможно масштабировать** отдельные части независимо
- **Синхронная обработка** - блокирующие операции замедляют весь процесс
- **Сложное тестирование** - нужно мокировать множество зависимостей
- **Нет Event Bus** - все вызовы прямые, нет асинхронной коммуникации
- **Нет защиты от дублирования** на уровне архитектуры (только в коде)
- **Нет валидации данных** как отдельного сервиса
- **Нет истории изменений** - нет таблиц для отслеживания изменений сумм/статусов

---

## Предложенная архитектура (Микросервисы)

### Структура

```
Микросервисы:
├── Payment Session Service         - создание сессий
├── Webhook Processing Service       - обработка webhook
├── Payment Processing Service       - валидация и сохранение платежей
├── Session Monitor Service          - мониторинг истекших сессий
├── Session Recreation Service      - пересоздание сессий
├── Reminder Scheduler Service       - планирование напоминаний
├── CRM Status Service               - обновление статусов CRM
├── Notification Service             - отправка уведомлений
├── Cash Payment Service             - управление наличными платежами
├── Exchange Rate Service            - курсы валют
├── Validation Service                - валидация данных
└── Duplicate Prevention Service     - защита от дубликатов

Event Bus (RabbitMQ/Kafka/Redis PubSub)
База данных (Supabase PostgreSQL)
```

### Как будет работать предложенная система

**1. Создание сессии:**
```
CRM → API Gateway
  → Payment Session Service
    ├── Validation Service (валидация данных)
    ├── Duplicate Prevention Service (проверка дубликатов)
    ├── Stripe API (создание сессии)
    └── Event Bus: session.created
      → Notification Service (отправка уведомления)
```

**2. Обработка платежа (webhook):**
```
Stripe Webhook → Webhook Processing Service
  ├── Валидация подписи
  ├── Duplicate Prevention Service (проверка event ID)
  └── Event Bus: payment.received
    → Payment Processing Service
      ├── Валидация и сохранение платежа
      ├── Exchange Rate Service (конвертация валют)
      └── Event Bus: payment.processed
        → CRM Status Service
          ├── Расчет статуса
          ├── Обновление в Pipedrive
          └── Event Bus: crm.status.updated
            → Notification Service (уведомление об оплате)
```

**3. Планирование напоминаний:**
```
Cron → Reminder Scheduler Service
  ├── Планирование задач
  └── Event Bus: reminder.due
    → Session Recreation Service (если нужно создать сессию)
    → Notification Service (отправка напоминания)
```

### Характеристики предложенной архитектуры

✅ **Преимущества:**
- **Разделение ответственности** - каждый сервис делает одну вещь
- **Независимое масштабирование** - можно масштабировать только нужные сервисы
- **Изоляция ошибок** - ошибка в одном сервисе не влияет на другие
- **Независимое развертывание** - можно обновлять сервисы отдельно
- **Event-driven** - асинхронная обработка через Event Bus
- **Защита от дублирования** - централизованный Duplicate Prevention Service
- **Валидация данных** - отдельный Validation Service с понятными ошибками
- **История изменений** - таблицы для отслеживания всех изменений
- **Простое тестирование** - каждый сервис тестируется изолированно

❌ **Сложности:**
- **Увеличение сложности** - больше компонентов для управления
- **Сетевая задержка** - коммуникация между сервисами
- **Распределенные транзакции** - нужны паттерны eventual consistency
- **Мониторинг** - нужно отслеживать множество сервисов
- **Отладка** - сложнее отследить поток через несколько сервисов

---

## Детальное сравнение

### 1. Создание сессий

| Аспект | Текущая система | Предложенная система |
|--------|----------------|---------------------|
| **Реализация** | `PaymentSessionCreator` класс внутри монолита | `Payment Session Service` (отдельный микросервис) |
| **Валидация** | В коде `PaymentSessionCreator` | `Validation Service` (отдельный сервис) |
| **Дубликаты** | Проверка в коде через `PaymentStateAnalyzer` | `Duplicate Prevention Service` (централизованный) |
| **Ошибки** | Логируются, но процесс может продолжиться | Сохранение состояния в БД, уведомление менеджера |
| **Перезапуск** | Нет механизма перезапуска | `Process States` таблица для перезапуска |

### 2. Обработка webhook

| Аспект | Текущая система | Предложенная система |
|--------|----------------|---------------------|
| **Реализация** | `routes/stripeWebhook.js` → `StripeProcessorService` | `Webhook Processing Service` (отдельный микросервис) |
| **Валидация** | В webhook handler | `Webhook Processing Service` + `Validation Service` |
| **Дубликаты** | Проверка по event ID в коде | `Duplicate Prevention Service` с таблицей `event_logs` |
| **Обработка** | Синхронная, все в одном процессе | Асинхронная через Event Bus |
| **Ошибки** | Могут заблокировать обработку других событий | Изолированы, не влияют на другие события |

### 3. Обработка платежей

| Аспект | Текущая система | Предложенная система |
|--------|----------------|---------------------|
| **Реализация** | `StripeProcessorService.persistSession()` (600+ строк) | `Payment Processing Service` (отдельный микросервис) |
| **Валидация** | Внутри `persistSession()` | `Validation Service` перед обработкой |
| **Конвертация валют** | `convertAmountWithRate()` внутри processor | `Exchange Rate Service` (отдельный сервис) |
| **Сохранение** | Прямой вызов repository | Через `Payment Processing Service` |
| **История** | Нет истории изменений | Таблицы `payment_status_history`, `payment_amount_history` |

### 4. Обновление статусов CRM

| Аспект | Текущая система | Предложенная система |
|--------|----------------|---------------------|
| **Реализация** | `StripeStatusAutomationService` (наследуется от `CrmStatusAutomationService`) | `CRM Status Service` (отдельный микросервис) |
| **Триггер** | Прямой вызов `triggerCrmStatusAutomation()` | Event Bus: `payment.processed` → `CRM Status Service` |
| **Расчет статуса** | Внутри `StripeStatusAutomationService` | `CRM Status Service` с использованием `StatusCalculator` |
| **Ошибки** | Логируются, но могут не обрабатываться | Изолированы, не влияют на обработку платежа |

### 5. Отправка уведомлений

| Аспект | Текущая система | Предложенная система |
|--------|----------------|---------------------|
| **Реализация** | `StripeProcessorService.sendPaymentNotificationForDeal()` | `Notification Service` (отдельный микросервис) |
| **Дубликаты** | In-memory кэш (`notificationCache`) в processor | `Duplicate Prevention Service` + таблица `notification_logs` с TTL |
| **Каналы** | SendPulse (Telegram) через `SendPulseClient` | `Notification Service` поддерживает множественные каналы |
| **Ошибки** | Логируются, но не блокируют процесс | Изолированы, не влияют на обработку платежа |

### 6. Мониторинг истекших сессий

| Аспект | Текущая система | Предложенная система |
|--------|----------------|---------------------|
| **Реализация** | `SecondPaymentSchedulerService.processExpiredSessions()` | `Session Monitor Service` + `Session Recreation Service` |
| **Расписание** | Cron каждые 4 часа | `Session Monitor Service` (cron) → Event Bus → `Session Recreation Service` |
| **Дубликаты** | Проверка в коде | `Duplicate Prevention Service` на уровне БД |
| **Уведомления** | Через `sendPaymentNotificationForDeal()` | Через `Notification Service` по событию |

### 7. Планирование напоминаний

| Аспект | Текущая система | Предложенная система |
|--------|----------------|---------------------|
| **Реализация** | `SecondPaymentSchedulerService` (2663 строки) | `Reminder Scheduler Service` (отдельный микросервис) |
| **Расписание** | Cron ежедневно в 09:00 | `Reminder Scheduler Service` (cron) → Event Bus → `Notification Service` |
| **Дубликаты** | Таблица `stripe_reminder_logs` с уникальным индексом | `Duplicate Prevention Service` + расширенная таблица `notification_logs` |
| **Задачи** | Хранятся в памяти и БД | Таблица `reminder_tasks` для персистентности |

### 8. Гибридные платежи

| Аспект | Текущая система | Предложенная система |
|--------|----------------|---------------------|
| **Реализация** | `CashPaymentsRepository` + логика в processor | `Cash Payment Service` (отдельный микросервис) |
| **Агрегация** | В коде processor | `Cash Payment Service` через Event Bus |
| **Подтверждение** | Ручное через API | `Cash Payment Service` с автоматизацией |

---

## Ключевые различия

### Архитектурный подход

| Характеристика | Текущая (Монолит) | Предложенная (Микросервисы) |
|----------------|------------------|---------------------------|
| **Количество компонентов** | 1 большой класс (6420 строк) | 12 независимых микросервисов |
| **Коммуникация** | Прямые вызовы методов | Event Bus (асинхронная) |
| **Масштабирование** | Вертикальное (больше ресурсов) | Горизонтальное (больше инстансов) |
| **Развертывание** | Один процесс | Независимое развертывание сервисов |
| **Тестирование** | Нужны моки множества зависимостей | Каждый сервис тестируется изолированно |
| **Отказоустойчивость** | Ошибка может сломать весь процесс | Ошибка изолирована в одном сервисе |

### Обработка данных

| Функция | Текущая система | Предложенная система |
|---------|----------------|---------------------|
| **Валидация** | В коде каждого метода | Централизованный `Validation Service` |
| **Дубликаты** | Проверка в коде, in-memory кэш | `Duplicate Prevention Service` + БД таблицы |
| **История изменений** | Нет | Таблицы `payment_status_history`, `payment_amount_history` |
| **Состояние процессов** | Нет сохранения | Таблица `process_states` для перезапуска |
| **Ошибки валидации** | Логируются | Сохраняются в `validation_errors`, уведомление менеджера |

### Защита от ошибок

| Аспект | Текущая система | Предложенная система |
|--------|----------------|---------------------|
| **Валидация данных** | В коде, ошибки логируются | `Validation Service`, ошибки сохраняются в БД |
| **Уведомления об ошибках** | Нет | Менеджер получает список ошибок |
| **Перезапуск процесса** | Нет механизма | Сохранение состояния → исправление → перезапуск |
| **Блокировка процесса** | Ошибка может заблокировать весь процесс | Ошибка изолирована, процесс продолжается |

---

## Что уже реализовано (частично)

### Существующие сервисы, которые можно использовать

1. **PaymentSessionCreator** - уже выделен в отдельный класс
   - ✅ Можно использовать как основу для `Payment Session Service`
   - ❌ Но он все еще вызывается из монолита

2. **PaymentScheduleService** - уже отдельный сервис
   - ✅ Можно использовать как есть
   - ✅ Используется в нескольких местах

3. **PaymentStateAnalyzer** - уже отдельный сервис
   - ✅ Можно использовать как есть
   - ✅ Анализ состояния платежей

4. **DistributedLockService** - уже реализован
   - ✅ Защита от race conditions
   - ✅ Таблица `stripe_payment_locks`

5. **ExchangeRateService** - уже отдельный модуль
   - ✅ Конвертация валют
   - ✅ Кэширование курсов

6. **StripeRepository** - уже отдельный класс
   - ✅ Работа с БД
   - ✅ Можно использовать как есть

7. **SendPulseClient** - уже реализован
   - ✅ Отправка уведомлений через SendPulse
   - ✅ Можно использовать в `Notification Service`

### Что нужно добавить

1. **Event Bus** - полностью отсутствует
2. **Validation Service** - нет отдельного сервиса
3. **Duplicate Prevention Service** - нет централизованного сервиса
4. **Process States** - нет таблицы для сохранения состояний
5. **History tables** - нет таблиц для истории изменений
6. **Notification Service** - уведомления встроены в processor
7. **Session Monitor Service** - логика в `SecondPaymentSchedulerService`
8. **Session Recreation Service** - логика в `SecondPaymentSchedulerService`

---

## План миграции

### Фаза 1: Подготовка инфраструктуры
- [ ] Настроить Event Bus (RabbitMQ/Kafka/Redis PubSub)
- [ ] Создать таблицы для истории и процессов
- [ ] Создать `Validation Service`
- [ ] Создать `Duplicate Prevention Service`

### Фаза 2: Выделение сервисов
- [ ] Выделить `Payment Session Service` из `PaymentSessionCreator`
- [ ] Выделить `Webhook Processing Service` из `routes/stripeWebhook.js`
- [ ] Выделить `Payment Processing Service` из `StripeProcessorService.persistSession()`
- [ ] Выделить `CRM Status Service` из `StripeStatusAutomationService`

### Фаза 3: Event-driven коммуникация
- [ ] Заменить прямые вызовы на события через Event Bus
- [ ] Настроить обработку событий в каждом сервисе
- [ ] Добавить retry механизмы для событий

### Фаза 4: Защита и валидация
- [ ] Интегрировать `Validation Service` во все точки входа
- [ ] Интегрировать `Duplicate Prevention Service`
- [ ] Добавить сохранение состояний процессов
- [ ] Добавить уведомления менеджерам об ошибках

### Фаза 5: Мониторинг и оптимизация
- [ ] Настроить мониторинг всех микросервисов
- [ ] Добавить метрики и алерты
- [ ] Оптимизировать производительность
- [ ] Документация и обучение команды

---

## Выводы

### Текущее состояние
- **Архитектура**: Монолитная
- **Основной класс**: `StripeProcessorService` (6420+ строк)
- **Коммуникация**: Прямые вызовы методов
- **Масштабирование**: Вертикальное
- **Защита от ошибок**: Базовая (логирование)
- **Валидация**: В коде каждого метода
- **Дубликаты**: Проверка в коде, in-memory кэш

### Предложенное состояние
- **Архитектура**: Микросервисная
- **Количество сервисов**: 12 независимых микросервисов
- **Коммуникация**: Event Bus (асинхронная)
- **Масштабирование**: Горизонтальное
- **Защита от ошибок**: Продвинутая (сохранение состояний, перезапуск)
- **Валидация**: Централизованный `Validation Service`
- **Дубликаты**: `Duplicate Prevention Service` + БД таблицы

### Различия
1. **Архитектурный подход**: Монолит → Микросервисы
2. **Коммуникация**: Синхронная → Асинхронная (Event Bus)
3. **Масштабирование**: Вертикальное → Горизонтальное
4. **Защита от ошибок**: Базовая → Продвинутая
5. **Валидация**: В коде → Отдельный сервис
6. **Дубликаты**: В коде → Централизованный сервис
7. **История**: Нет → Полная история изменений
8. **Перезапуск**: Нет → Сохранение состояния и перезапуск

### Готовность к миграции
- **Инфраструктура**: 30% (есть БД, нет Event Bus)
- **Сервисы**: 40% (есть базовые сервисы, но они встроены в монолит)
- **Защита**: 20% (базовая защита, нет продвинутых механизмов)
- **Мониторинг**: 30% (есть логирование, нет централизованного мониторинга)

**Общая готовность**: ~30% - есть хорошая база, но нужна значительная работа для миграции на микросервисы.
