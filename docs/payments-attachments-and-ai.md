## Платежи: вложения (чек/инвойс) и будущая AI-автоматизация

### Контекст (как сейчас)

У нас есть банковские платежи, загружаемые из CSV, которые попадают в таблицу `payments`.

Дальше пользователь:

- назначает категории (PNL) / мэчит платежи к проформам (для `direction=in`);
- **вручную привязывает платежи к продуктам** (см. `docs/payments-product-linking.md`), чтобы VAT Margin по продукту учитывал дополнительные расходы/приходы.

---

### Новая фича: “вложения к платежу”

Цель: дать возможность **прикреплять к банковскому платежу** фото чека / скан инвойса / PDF, чтобы:

- хранить первичку рядом с конкретной транзакцией;
- использовать эти вложения для последующего **распознавания (OCR/LLM)** и подсказок (категория/продукт/контрагент).

Ключевое решение: вложения — это отдельная сущность, связанная с `payments.id`.

---

### P1 (минимально полезное): ручная загрузка вложений в карточке платежа

#### UX

- В деталях платежа (в первую очередь на странице “Expenses”) добавить блок:
  - “Загрузить чек/инвойс” (drag&drop + кнопка),
  - список уже загруженных файлов:
    - превью (для изображений),
    - имя/дата/размер,
    - кнопки “Открыть” и “Удалить”.

#### Хранилище

Рекомендуемо: **Supabase Storage** (bucket, например `payment-attachments`).

Путь объекта: `payments/<paymentId>/<attachmentId>/<originalFilename>`

Почему так:

- дешево и удобно для публичных/подписанных ссылок;
- не раздуваем таблицу `payments`;
- можно безопасно отдавать **signed URL**.

#### База данных (минимальная схема)

Таблица: `payment_attachments`

Минимальные поля:

- `id` UUID (PK)
- `payment_id` (FK на `payments.id`)
- `storage_bucket` (например `payment-attachments`)
- `storage_path` (полный путь внутри bucket)
- `mime_type`
- `size_bytes`
- `original_filename`
- `uploaded_by` (email/id, если доступно)
- `uploaded_at` (timestamp)
- `deleted_at` (soft delete, опционально)

Полезно добавить:

- `sha256` (для дедупликации)
- `source` ENUM: `manual`, `import`, `ai`

#### API (предлагаемый контракт)

1) **Загрузить вложение к платежу**

`POST /api/payments/:id/attachments`

- `multipart/form-data`:
  - `file` (обязателен)
- ограничения:
  - max size (например 10MB, как у нас уже настроено для других upload)
  - whitelist типов: `image/jpeg`, `image/png`, `application/pdf`

Ответ:

```json
{ "success": true, "data": { "id":"…", "payment_id": 1001, "original_filename":"receipt.jpg", "mime_type":"image/jpeg", "size_bytes":12345, "uploaded_at":"…"} }
```

2) **Список вложений платежа**

`GET /api/payments/:id/attachments`

Ответ:

```json
{ "success": true, "data": [ { "id":"…", "original_filename":"…", "uploaded_at":"…" } ] }
```

3) **Получить ссылку на скачивание/просмотр**

Варианты:

- `GET /api/payments/:id/attachments/:attachmentId/url` → returns signed URL (предпочтительно)
- либо `GET /api/payments/:id/attachments/:attachmentId/download` → проксировать файл через backend

4) **Удалить вложение**

`DELETE /api/payments/:id/attachments/:attachmentId`

- удаляет запись и файл (или делает soft delete + удаляет из bucket).

#### Валидации (важно)

- нельзя добавлять вложения к удаленному платежу (`payments.deleted_at`)
- только существующий платеж
- контроль типов/размера
- не логировать содержимое файла, только метаданные (и следить за PII)

---

### P2: AI распознавание вложений и подсказки (ChatGPT / Vision / OCR)

Цель: после загрузки чека/инвойса система автоматически извлекает:

- поставщика/контрагента
- дату документа
- сумму и валюту
- назначение/позиции (если есть)
- признаки продукта (по ключевым словам)

и показывает пользователю:

- “Предложенная категория расходов”
- “Предложенный продукт”
- “Уверенность / причина”

#### Что именно “автоматизировать”

Есть 2 разных сценария, их лучше разделить:

**Сценарий A (проще, быстрее):** пользователь уже выбрал конкретный платеж → загрузил чек к нему.

- AI делает **классификацию/подсказки** (категория/продукт), но не “ищет платёж”.

**Сценарий B (следующий шаг):** пользователь загружает чек “в инбокс”, а система ищет, к какому банковскому платежу он относится.

- AI извлекает сумму/валюту/дату/вендора и пытается сматчить к `payments` по:
  - сумме (с допуском),
  - валюте,
  - дате (окно ±N дней),
  - тексту/вендору ↔ `payments.description` / `payer_name`.

Рекомендация: начать со **Сценария A**, он минимально рискованный и даёт ценность сразу.

#### Данные AI-анализа (таблица)

Таблица: `payment_attachment_analyses` (или поля прямо в `payment_attachments`, но лучше отдельно)

- `id` UUID
- `attachment_id` (FK)
- `status`: `queued` / `processing` / `done` / `failed`
- `model` (например `gpt-4.1-mini`, `gpt-4.1`, etc.)
- `extracted` JSON:
  - `vendor_name`
  - `document_date`
  - `total_amount`
  - `currency`
  - `tax_amount` (если есть)
  - `line_items` (если есть)
  - `raw_text` (если делаем OCR)
- `suggestions` JSON:
  - `suggested_product_id`
  - `suggested_product_reason`
  - `suggested_expense_category_id`
  - `confidence`
- `created_at`, `updated_at`
- `error` (если failed)

#### API для AI (предлагаемо)

- `POST /api/payments/:id/attachments/:attachmentId/analyze` — поставить в очередь анализ
- `GET /api/payments/:id/attachments/:attachmentId/analyze` — статус/результат

Реализация может быть асинхронной (через scheduler/worker), чтобы не держать HTTP.

---

### Как это свяжется с “линковкой к продукту”

Идеальная цепочка:

1) CSV банка → `payments`
2) пользователь прикрепил чек/инвойс к платежу
3) AI анализирует чек → предлагает продукт
4) пользователь **в один клик** подтверждает и вызывает существующий эндпоинт:

`POST /api/payments/:id/link-product { "productId": ... }`

То есть AI не заменяет ручной контроль, а делает “suggest + confirm”.

---

### Риски и меры

- **PII/финансовые данные**: хранить доступ к файлам через signed URL, не публиковать публично.
- **Стоимость AI**: анализ делать по кнопке или батчами, кэшировать результаты.
- **Ошибки распознавания**: всегда показывать “reason + confidence”, всегда оставлять ручной выбор.

